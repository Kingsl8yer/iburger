{
  "version": 3,
  "sources": [
    "components/UI/Input/Input.module.css",
    "components/Order/CheckoutSummary/CheckoutSummary.module.css",
    "components/Checkout/ContactData/ContactData.module.css",
    "components/Order/CheckoutSummary/CheckoutSummary.js",
    "components/Checkout/ContactData/ContactData.js",
    "components/Checkout/Checkout.js",
    "components/UI/Input/Input.js"
  ],
  "names": [
    "module",
    "exports",
    "checkoutSummary",
    "props",
    "className",
    "classes",
    "CheckoutSummary",
    "style",
    "width",
    "margin",
    "Burger",
    "ingredients",
    "Button",
    "btnType",
    "clicked",
    "checkoutCancelled",
    "checkoutContinued",
    "ContactData",
    "state",
    "orderForm",
    "name",
    "elementType",
    "elementConfig",
    "type",
    "placeholder",
    "value",
    "validation",
    "required",
    "valid",
    "touched",
    "street",
    "zipCode",
    "minLength",
    "maxLength",
    "country",
    "email",
    "deliveryMethod",
    "options",
    "displayValue",
    "formIsValid",
    "orderHandler",
    "event",
    "preventDefault",
    "formData",
    "formElementIdentifier",
    "order",
    "ings",
    "price",
    "orderData",
    "userId",
    "onOrderBurger",
    "token",
    "inputChangedHandler",
    "inputIdentifier",
    "updatedFormElement",
    "updateObject",
    "target",
    "checkValidity",
    "updatedOrderForm",
    "setState",
    "formElementsArray",
    "key",
    "this",
    "push",
    "id",
    "config",
    "form",
    "onSubmit",
    "map",
    "formElement",
    "Input",
    "invalid",
    "shouldValidate",
    "changed",
    "disabled",
    "loading",
    "Spinner",
    "Component",
    "connect",
    "burgerBuilder",
    "totalPrice",
    "auth",
    "dispatch",
    "actions",
    "withErrorHandler",
    "axios",
    "Checkout",
    "checkoutCancelledHandler",
    "history",
    "goBack",
    "checkoutContinuedHandler",
    "replace",
    "summary",
    "to",
    "purchasedRedirect",
    "purchased",
    "path",
    "match",
    "component",
    "input",
    "inputElement",
    "inputClasses",
    "InputElement",
    "Invalid",
    "join",
    "onChange",
    "option",
    "Label",
    "label"
  ],
  "mappings": "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",
  "file": "static/js/3.92382e4a.chunk.js",
  "sourcesContent": [
    "// extracted by mini-css-extract-plugin\nmodule.exports = {\"Input\":\"Input_Input__1priY\",\"Label\":\"Input_Label__-BPFS\",\"InputElement\":\"Input_InputElement__bzdjc\",\"Invalid\":\"Input_Invalid__3Eyof\"};",
    "// extracted by mini-css-extract-plugin\nmodule.exports = {\"CheckoutSummary\":\"CheckoutSummary_CheckoutSummary__3JnLK\"};",
    "// extracted by mini-css-extract-plugin\nmodule.exports = {\"ContactData\":\"ContactData_ContactData__2Belm\"};",
    "import React from \"react\";\r\nimport Burger from \"../../Burger/Burger\";\r\nimport Button from \"../../UI/Button/Button\";\r\nimport classes from  './CheckoutSummary.module.css'\r\n\r\nconst checkoutSummary = (props)=>{\r\n    return(\r\n        <div className={classes.CheckoutSummary}>\r\n            <h1>We hope it tastes well</h1>\r\n            <div style={{width: '100%', margin: 'auto'}}>\r\n                <Burger ingredients={props.ingredients}/>\r\n            </div>\r\n            <Button btnType=\"Danger\"\r\n            clicked={props.checkoutCancelled}>\r\n                CANCEL</Button>\r\n            <Button btnType=\"Success\"\r\n            clicked={props.checkoutContinued}>\r\n                CONTINUE</Button>\r\n        </div>\r\n    )\r\n}\r\nexport default checkoutSummary;",
    "import React, {Component} from \"react\";\r\nimport {connect} from 'react-redux';\r\nimport Button from \"../../UI/Button/Button\";\r\nimport classes from './ContactData.module.css';\r\nimport axios from '../../../axios-orders';\r\nimport Spinner from \"../../UI/Spinner/Spinner\";\r\nimport Input from \"../../UI/Input/Input\";\r\nimport withErrorHandler from \"../../../hoc/withErrorHandler/withErrorHandler\";\r\nimport {updateObject, checkValidity} from \"../../../shared/utility\";\r\nimport * as actions from '../../../store/actions/index';\r\n\r\nclass ContactData extends Component {\r\n    state = {\r\n        orderForm: {\r\n            name: {\r\n                elementType: 'input',\r\n                elementConfig: {\r\n                    type: 'text',\r\n                    placeholder: 'Your Name'\r\n                },\r\n                value: '',\r\n                validation: {\r\n                    required: true\r\n                },\r\n                valid: false,\r\n                touched: false\r\n            },\r\n            street: {\r\n                elementType: 'input',\r\n                elementConfig: {\r\n                    type: 'text',\r\n                    placeholder: 'Your Street'\r\n                },\r\n                value: '',\r\n                validation: {\r\n                    required: true\r\n                },\r\n                valid: false,\r\n                touched: false\r\n            },\r\n            zipCode: {\r\n                elementType: 'input',\r\n                elementConfig: {\r\n                    type: 'text',\r\n                    placeholder: 'ZIP Code'\r\n                },\r\n                value: '',\r\n                validation: {\r\n                    required: true,\r\n                    minLength: 5,\r\n                    maxLength: 5\r\n                },\r\n                valid: false,\r\n                touched: false\r\n            },\r\n            country: {\r\n                elementType: 'input',\r\n                elementConfig: {\r\n                    type: 'text',\r\n                    placeholder: 'Your country'\r\n                },\r\n                value: '',\r\n                validation: {\r\n                    required: true\r\n                },\r\n                valid: false,\r\n                touched: false\r\n            },\r\n            email: {\r\n                elementType: 'input',\r\n                elementConfig: {\r\n                    type: 'email',\r\n                    placeholder: 'Your E-Mail'\r\n                },\r\n                value: '',\r\n                validation: {\r\n                    required: true\r\n                },\r\n                valid: false,\r\n                touched: false\r\n            },\r\n            deliveryMethod: {\r\n                elementType: 'select',\r\n                elementConfig: {\r\n                    options: [\r\n                        {value: 'fastest', displayValue: 'Fastest'},\r\n                        {value: 'cheapest', displayValue: 'Cheapest'}\r\n                    ]\r\n                },\r\n                value: 'fastest',\r\n                validation: {},\r\n                /*I still add this 'valid' property to the dropdown even though it of course doesn't have any validation rules but therefore it should always be 'valid'(true)*/\r\n                valid: true\r\n            }\r\n        },\r\n        formIsValid: false\r\n    }\r\n\r\n    orderHandler = (event) => {\r\n        /*'PreventDefault()' is important on the 'orderHandler' on the event you're getting automatically to prevent the default which would be to send the request and reload the page.*/\r\n        event.preventDefault();\r\n        //this.setState({loading: true});\r\n        /*I just want to get the 'name' and then the 'value' directly mapped to each other.*/\r\n        const formData = {};\r\n        /*So there I'll have my 'formElementIdentifier' in this.state.orderForm, so this very long form element identifier is simply 'email', 'country' and so on.*/\r\n        for (let formElementIdentifier in this.state.orderForm) {\r\n            formData[formElementIdentifier] = this.state.orderForm[formElementIdentifier].value;\r\n        }\r\n        const order = {\r\n            ingredients: this.props.ings,\r\n            price: this.props.price,\r\n            orderData: formData,\r\n            userId: this.props.userId\r\n            /*customer: {\r\n                name: 'Miguel Varona',\r\n                address: {\r\n                    street: 'Las Delicias',\r\n                    zipCode: 'M1 4FG',\r\n                    country: 'Canada'\r\n                },\r\n                email: 'test@test.com'\r\n            },\r\n            deliveryMethod: 'fastest'*/\r\n        }\r\n        // axios.post('/orders.json', order).then(response => {\r\n        //     /*Now one thing I want to do is this 'purchasing' state which I'm setting here is not  required any more, 'loading' is a state I don't use yet.*/\r\n        //     this.setState({loading: false});\r\n        //     this.props.history.push('/');\r\n        // })\r\n        //     .catch(error => {\r\n        //         this.setState({loading: false});\r\n        //     });\r\n        this.props.onOrderBurger(order, this.props.token);\r\n    }\r\n\r\n\r\n    /*We need to update the this.state.value for a given input upon user changes*/\r\n    /*We also receive or need a second argument which is the 'inputIdentifier' so that we can reach out to our 'state', get the right element here, the right object and adjust its value.*/\r\n    inputChangedHandler = (event, inputIdentifier) => {\r\n        /*I'll first of all create my copy of my form data(updatedOrderForm), however this does not create a deep clone, so I copy that object and I distribute all the properties, I get a new\r\n        object but since in these objects, I have more nested objects, these would not be cloned deeply*/\r\n        //const updatedOrderForm = {...this.state.orderForm};\r\n\r\n        /*I'll take the updatedOrderForm which is a clone of the original and there I'll now access my 'inputIdentifier' so this is a value like 'email', like deliveryMethod.*/\r\n        /*Now I get access to this object which we haven't cloned already so now I need to clone that object and I'll store it in the new constant 'updatedFormElement'. Now I can safely change\r\n        the value of the 'updatedFormElement' because it is again a clone.*/\r\n        const updatedFormElement = updateObject(this.state.orderForm[inputIdentifier], {\r\n            value: event.target.value,\r\n            valid: checkValidity(event.target.value, this.state.orderForm[inputIdentifier].validation),\r\n          touched: true\r\n            });\r\n        const updatedOrderForm =updateObject(this.state.orderForm, {\r\n            /* The new property should be this dynamic '[inputIdentifier]' where we pick a specific control, which we of course store as properties in our order form object in the state,\r\n           like name, street and so on.*/\r\n            [inputIdentifier]: updatedFormElement\r\n        });\r\n\r\n        /*So I will reach out to 'updatedFormElement.value' and set this equal to 'event.target.value'*/\r\n        //updatedFormElement.value = event.target.value;\r\n\r\n        /*I want to set 'updatedFormElement.valid' equal to 'this.checkValidity' and pass the 'updatedFormElement.value' which we already adjusted to the value passed by the event\r\n         and of course I want to pass my 'updatedFormElement.validation' object which is just my 'rules' on  'checkValidity()'.*/\r\n        //updatedFormElement.valid = this.checkValidity(updatedFormElement.value, updatedFormElement.validation);\r\n\r\n        /*So now to update the 'touched' value, I'll go to my 'inputChangedHandler' where we of course know that the user typed something or changed something so at this point of time\r\n        something has been changed. And now in there, I want to update 'touched' */\r\n        //updatedFormElement.touched = true;\r\n\r\n        /*I can now again access the 'inputIdentifier' and set it equal to the 'updatedFormElement'. Now with this, I can call this.setState and set order form to updated order form.*/\r\n        //updatedOrderForm[inputIdentifier] = updatedFormElement;\r\n\r\n\r\n        /*So with that, we should now know the overall form validity and this allows us to disable the button.*/\r\n        let formIsValid = true;\r\n        for (let inputIdentifier in updatedOrderForm) {\r\n            formIsValid = updatedOrderForm[inputIdentifier].valid && formIsValid;\r\n        }\r\n\r\n        this.setState({orderForm: updatedOrderForm, formIsValid: formIsValid});\r\n    }\r\n\r\n    render() {\r\n        /*I now need to first of all turn my this.state.orderForm object into some kind of array I can loop through*/\r\n        const formElementsArray = [];\r\n        for (let key in this.state.orderForm) {\r\n            formElementsArray.push({\r\n                id: key,\r\n                config: this.state.orderForm[key]\r\n            });\r\n        }\r\n        /*I'll add my 'form' variable which is the <form> down there by default but if this.state.loading is true, then 'form' will actually be this <Spinner/> component. So let me grab\r\n        the <form> from down there, I pointed into the 'form' variable up here and then, I'll just output form here, this 'form' variable which either is the form or the  <Spinner/>.*/\r\n        let form = (\r\n            /* All the other things here, 'placeholder' and so on should really be passed on now because we pass on props, that is what we define in our Input component.*/\r\n            <form onSubmit={this.orderHandler}>\r\n                {/*<Input elementType=\"...\" elementConfig=\"...\" value=\"...\"/>*/}\r\n                {formElementsArray.map(formElement => (\r\n                    <Input key={formElement.id}\r\n                           elementType={formElement.config.elementType}\r\n                           elementConfig={formElement.config.elementConfig}\r\n                           value={formElement.config.value}\r\n                           invalid={!formElement.config.valid}\r\n                        /* 'shouldValidate' should only be true if my object in the 'orderForm' has a 'validation' object, my 'delivery' method which is the dropdown in the end hasn't so it\r\n                        shouldn't validate at all.*/\r\n                           shouldValidate={formElement.config.validation}\r\n                           touched={formElement.config.touched}\r\n\r\n                        /*I'll go to my 'ContactData' component and the method I passed to 'changed', the reference here should be a referenced to an anonymous function so that I can now\r\n                        pass arguments to the 'inputChangedHandler' method call. In this anonymous function, here we now get this 'event' object which is created by React automatically\r\n                        and I want to pass this on but I also now want to pass my 'identifier'(id), which is form element ID */\r\n                           changed={(event) => this.inputChangedHandler(event, formElement.id)}\r\n                    />\r\n                ))}\r\n                {/*We are not using the original html button there, we're using our own implementation so there we need to expect a 'disabled' prop and pass it on to the native button 'disabled' attribute.*/}\r\n                <Button btnType=\"Success\" disabled={!this.state.formIsValid}>ORDER</Button>\r\n            </form>\r\n        );\r\n        if (this.props.loading) {\r\n            form = <Spinner/>;\r\n        }\r\n        return (\r\n            <div className={classes.ContactData}>\r\n                <h4>Enter your Contact Data</h4>\r\n                {form}\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nconst mapStateToProps = state => {\r\n    return {\r\n        ings: state.burgerBuilder.ingredients,\r\n        price: state.burgerBuilder.totalPrice,\r\n        loading: state.order.loading,\r\n        token: state.auth.token,\r\n        userId: state.auth.userId\r\n    }\r\n};\r\n\r\nconst mapDispatchToProps = dispatch => {\r\n    return {\r\n        onOrderBurger: (orderData, token) => dispatch(actions.purchaseBurger(orderData, token))\r\n    };\r\n};\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(withErrorHandler(ContactData, axios));",
    "import React, {Component} from \"react\";\r\nimport { connect } from 'react-redux';\r\nimport CheckoutSummary from \"../Order/CheckoutSummary/CheckoutSummary\";\r\nimport ContactData from \"./ContactData/ContactData\";\r\nimport {Route, Redirect} from \"react-router-dom\";\r\n\r\n\r\n\r\nclass Checkout extends Component {\r\n\r\n\r\n    state = {\r\n        ingredients: null,\r\n        totalPrice: 0\r\n    }\r\n    /*Now of course I need to parse this in the checkout component and then I'll do this in componentDidMount, I won't use componentDidUpdate or anything like that because whenever\r\n    I load this component, it will mount itself, there is no way I can route to it without it being mounted again because it's not nested in some other page or anything like that.*/\r\n\r\n    /*The initial ingredients here are null though and if we pass that to contact data and we try to render the burger there, this doesn't work with ingredients that are null. Now to\r\n    fix this, what we can do is we can simply change componentDidMount to WillMount before we render the child component, we already have access to the props there so we can\r\n    already get the queryParams there.*/\r\n\r\n    // componentWillMount() {\r\n    //     /*Now in there I will want to use the code you saw before(this.props.history.push({ pathname: '/checkout', search: '?' +queryString }); to extract the query parameters.*/\r\n    //     const query = new URLSearchParams(this.props.location.search);\r\n    //     const ingredient = {};\r\n    //     let price = 0;\r\n    //     for(let param of query.entries()){\r\n    //         if(param[0]==='price'){\r\n    //             price=param[1];\r\n    //         }else{\r\n    //             //['salad', '1']\r\n    //             /*We can convert param[1] into a number by adding a plus*/\r\n    //             ingredient[param[0]]= +param[1];\r\n    //         }\r\n    //\r\n    //     }\r\n    //     this.setState({ingredients: ingredient, totalPrice: price});\r\n    // }\r\n\r\n    checkoutCancelledHandler = () => {\r\n        this.props.history.goBack();\r\n    }\r\n\r\n    checkoutContinuedHandler = () => {\r\n        /*'ll use replace instead to replace the current route with checkout/contactData for example.*/\r\n        this.props.history.replace('checkout/contact-data');\r\n    }\r\n\r\n    render() {\r\n        let summary = <Redirect to=\"/\"/>\r\n\r\n        if(this.props.ings){\r\n            const purchasedRedirect = this.props.purchased ? <Redirect to=\"/\"/> : null;\r\n                summary = (\r\n                <div>\r\n                    {purchasedRedirect}\r\n                <CheckoutSummary\r\n                    ingredients={this.props.ings}\r\n                    checkoutCancelled={this.checkoutCancelledHandler}\r\n                    checkoutContinued={this.checkoutContinuedHandler}/>\r\n\r\n            <Route path={this.props.match.path + '/contact-data'}\r\n                   component={ContactData}/>\r\n                </div>\r\n            );\r\n        }\r\n        return summary;\r\n    }\r\n    /*Now we don't need 'mapDispatchToProps' here because we're not actually dispatching anything in this container, we just navigate a little bit but we don't do this through redux store,\r\n    we do this through the react router so there is nothing getting dispatched here, so for now we only need mapStateToProps,*/\r\n\r\n}\r\n\r\nconst mapStateToProps = state => {\r\n    return{\r\n        ings: state.burgerBuilder.ingredients,\r\n        purchased: state.order.purchased\r\n    }\r\n};\r\n\r\n\r\n\r\nexport default connect(mapStateToProps) ( Checkout);",
    "import React from \"react\";\r\nimport classes from './Input.module.css';\r\n\r\nconst input = (props) => {\r\n    let inputElement = null;\r\n    /*I will add a new constant which I'll name 'inputClasses' which is an array which at the beginning is just 'classes.inputElement' */\r\n    const inputClasses = [classes.InputElement];\r\n    if(props.invalid && props.shouldValidate && props.touched){\r\n        inputClasses.push(classes.Invalid);\r\n    }\r\n\r\n    /*And now to handle the case that we also have different attributes, I expect to get the attributes you want to set on <input> as props for our <input {...props}/> wrapper. This then allows\r\n    me to simply distribute them on the <input> element, so any default html attributes you want to set on your <input>, you only need to set the input type prop and then you pass the\r\n    normal attributes you would pass to that type, so if you have a <textarea>, you simply pass the normal props you want it to pass from outside and inside of my custom <input> component,\r\n    I don't have to worry about which exact type we have. I rely on you using the wrapper correctly and passing the correct normal html attributes, this is a way of reducing the\r\n    complexity here so that I only have to set the right element and then you take care about the props.*/\r\n    switch (props.elementType) {\r\n        case('input'):\r\n            inputElement = <input className={inputClasses.join(' ')}\r\n                                  {...props.elementConfig}\r\n                                  value={props.value}\r\n                                  onChange={props.changed}/>;\r\n            break;\r\n        case('textarea'):\r\n            inputElement = <textarea className={inputClasses.join(' ')}\r\n                                     {...props.elementConfig}\r\n                                     value={props.value}\r\n                                     onChange={props.changed}/>;\r\n            break;\r\n        case('select'):\r\n            inputElement = <select\r\n                className={inputClasses.join(' ')}\r\n                value={props.value}\r\n                onChange={props.changed}>\r\n                {props.elementConfig.options.map(\r\n                    option =>(\r\n                        <option key={option.value} value={option.value}>\r\n                            {option.displayValue}\r\n                        </option>\r\n                    )\r\n                )}\r\n                           </select>;\r\n            break;\r\n        default:\r\n            inputElement = <input className={inputClasses.join(' ')}\r\n                                  {...props.elementConfig}\r\n                                  value={props.value}\r\n                                  onChange={props.changed}/>;\r\n    }\r\n\r\n    return (\r\n        <div className={classes.Input}>\r\n            <label className={classes.Label}>{props.label}</label>\r\n            {inputElement}\r\n        </div>\r\n    );\r\n}\r\nexport default input;\r\n"
  ],
  "sourceRoot": ""
}